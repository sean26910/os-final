#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <time.h>
#define SIZE 80

int arr[SIZE][SIZE];
int result[SIZE][SIZE] = {0};
bool isStart = false;

typedef struct my_pid
{
    int pid;
} my_pid;

/* don't change */
void readMatrix()
{
    FILE *fp;
    fp = fopen("number.txt", "r");
    for (int i = 0; i < SIZE; i++)
    {
        for (int j = 0; j < SIZE; j++)
        {
            fscanf(fp, "%d", &arr[i][j]);
        }
    }
    fclose(fp);
}

/* don't change */
void multipfy()
{
    for (int i = 0; i < SIZE; i++)
    {
        for (int j = 0; j < SIZE; j++)
        {
            for (int k = 0; k < SIZE; k++)
            {
                result[i][j] += arr[i][k] * arr[k][j];
            }
        }
    }
}

/* don't change */
long sum()
{
    long ret = 0;
    for (int i = 0; i < SIZE; i++)
    {
        for (int j = 0; j < SIZE; j++)
        {
            ret += result[i][j];
        }
    }
    return ret;
}

/* don't change */
void diff(struct timespec start, struct timespec end)
{
    struct timespec temp;
    if ((end.tv_nsec - start.tv_nsec) < 0)
    {
        temp.tv_sec = end.tv_sec - start.tv_sec - 1;
        temp.tv_nsec = 1000000000 + end.tv_nsec - start.tv_nsec;
    }
    else
    {
        temp.tv_sec = end.tv_sec - start.tv_sec;
        temp.tv_nsec = end.tv_nsec - start.tv_nsec;
    }
    printf("Time = %ld seconds and %ld nanoseconds\n", temp.tv_sec, temp.tv_nsec);
}

/*-----------------------------------------------*/
/*                  Hint version                 */
/*-----------------------------------------------*/

/* 用 system + /proc/cpuinfo 找最後一顆 core */
int getLastCore()
{
    // 將整行 "cpu cores : X" 寫入 CPUINFO
    system("grep -m1 \"cpu cores\" /proc/cpuinfo > CPUINFO");

    FILE *fp = fopen("CPUINFO", "r");
    if (!fp)
    {
        perror("CPUINFO");
        exit(1);
    }

    char tmp[128];
    fgets(tmp, sizeof(tmp), fp);
    fclose(fp);

    // 從整行字串中擷取最後的數字
    int cores = 0;

    // 找字串中最後一個連續的數字
    for (int i = 0; tmp[i] != '\0'; i++)
    {
        if (tmp[i] >= '0' && tmp[i] <= '9')
        {
            // 將字元 '0'~'9' 轉成數字
            cores = cores * 10 + (tmp[i] - '0');
        }
    }

    if (cores <= 0)
        cores = 1; // fallback（避免出錯）

    // CPU core 編號從 0 開始 → 最後一顆 core = cores - 1
    return cores - 1;
}

/* 使用 taskset 指令綁定 thread 到某顆 core */
void setTaskToCore(my_pid *pid)
{
    int core = getLastCore();

    // 等待 child 設定 pid->pid (thread id)
    while (pid->pid == 0);

    char cmd[128];
    sprintf(cmd, "taskset -cp %d %d", core, pid->pid);

    system(cmd); // 綁定 CPU core
}

/* 子執行緒 */
void *child(void *arg)
{
    long *ret = calloc(1, sizeof(long));
    my_pid *pid = (my_pid *)arg;

    int process_id = syscall(SYS_getpid); // 取得 process id
    int thread_id = syscall(SYS_gettid);  // 取得 thread id

    pid->pid = thread_id; // 傳回給主程式

    printf("Process Id: %d\n", process_id);
    printf("Thread Id: %d\n", thread_id);

    /* don't change */
    while (!isStart);
    multipfy();
    *ret = sum();
    /* ------------ */

    pthread_exit(ret);
}

/*-----------------------------------------------*/

int main()
{
    pthread_t thread;
    void *ret;
    my_pid pid = {0};
    struct timespec timeStart, timeEnd;

    printf("Process Id: %d\n", getpid());
    printf("Thread Id: %ld\n", syscall(SYS_gettid));

    readMatrix();

    pthread_create(&thread, NULL, child, &pid);

    setTaskToCore(&pid);

    sleep(1);

    isStart = true;
    clock_gettime(CLOCK_REALTIME, &timeStart);

    pthread_join(thread, &ret);

    clock_gettime(CLOCK_REALTIME, &timeEnd);

    printf("Sum = %ld\n", *(long *)ret);
    diff(timeStart, timeEnd);

    free(ret);

    return 0;
}
